---
title: "Handon_11"
editor: visual
---

```{r}
pacman::p_load(tidyverse,tmap,sf,sfdep,readr)
```

```{r}
sydney = read_csv("data/aspatial/airbnb_sydney2022_detail.csv")
```

```{r}
library(ggmap)


# Create a new column for zip code and initialize with empty strings
sydney$zipcode <- ""

# Loop through each row and use ggmap to retrieve the zip code
for (i in 1:nrow(sydney)) {
  lat <- sydney[i, "latitude"]
  lon <- sydney[i, "longitude"]
  result <- revgeocode(c(lon, lat), output = "more")
  sydney[i, "zipcode"] <- result$postal_code
  Sys.sleep(1)  # Pause for 1 second to avoid overloading the geocoding service
}

# Write the updated data frame to a new CSV file
write.csv(sydney, "updated_file.csv", row.names = FALSE)
```

```{r}
install.packages("geosphere")
```

```{r}
install.packages("geocode")
```

```{r}
library(geosphere)

# Check that 'sydney' dataframe has numeric longitude and latitude columns
if (!is.numeric(sydney$longitude) || !is.numeric(sydney$latitude)) {
  stop("Longitude and latitude columns must be numeric")
}

# reverse geocode to get the zipcode
sydney$zipcode <- apply(sydney, 1, function(row) {
  location <- c(as.numeric(row["longitude"]), as.numeric(row["latitude"]))
  result <- revgeocode(location, output = "address")
  if (is.null(result$postal_code)) {
    warning("Postal code not found for row ", which(apply(sydney, 1, function(x) all.equal(x, row))), ". Setting to NA.")
    postal_code <- NA
  } else {
    postal_code <- result$postal_code
  }
  return(postal_code)
})
```

```{r}
library(geosphere)

# reverse geocode to get the zipcode
sydney$zipcode <- apply(sydney, 1, function(row) {
  location <- c(row["longitude"], row["latitude"])
  result <- revgeocode(location, output = "address")
  postal_code <- result$postal_code
  return(postal_code)
})
```
