---
title: "TakeHome_Ex1"
author: "Lu Quanfang"
date: "30 January 2023"
date_modified: "r Sys.Date()"
---

# Analysis on the geographic distribution of functional and non-function water points in Osub State, Nigeria

## 1.Background

Access to clean and abundant water is a vital necessity for human health and well-being. Adequate Clean water is crucial in promoting a healthy environment, sustaining economic growth in countries. However, a significant portion of the global population, including those in Nigeria, are still grappling with a lack of access to sufficient water resources. Given the critical role that water plays in many aspects of life, it is essential to understand the current water distribution system and identify potential areas for improvement.

## 2.Objectives

Apply appropriate spatial point patterns analysis method to discover the geographical distribution of functional and non-function water points an and their co-locations

## 3. Steps

### 3.1 Exploratory Spatial Data Analysis (ESDA)

##### 3.1.1 Load necessary R-package and import the geospatial dataset

The package we used for analysis are:

-   **sf**: For importing, managing and processing vector-based geospatial data

-   **tidyverse**: For performing data science tasks such as importing, wrangling and visualising data.

-   **tmap**: used for creating thematic maps, such as choropleth and bubble maps

-   **raster:** reads, writes, manipulates, analyses and models gridded spatial data

-   **spatstat**: used for point pattern analysis

-   **maptools**: a set of tools for manipulating geographic data

-   **funModeling**: used for exploratory data analysis

Let's load the package required!

```{r}
pacman::p_load(maptools, sf, raster, spatstat, tmap,tidyverse,plotly,funModeling,sfdep)
```

Here are two possible datasets that we can obtain the geospatial information of Nigeria from, one is from [Humanitarian Data Exchange](https://data.humdata.org/) portal, the other is from [geoBoundaries](https://www.geoboundaries.org/), let's read both of the datasets and examine which one is more suitable to use, **notice that the crs for Nigeria should be 23692, so we need to assign the crs after reading the data**:

```{r}
geoNGA <- st_read("data/geospatial/",
                  layer = "geoBoundaries-NGA-ADM2") %>%
  st_transform(crs = 26392)
```

```{r}
NGA <- st_read("data/geospatial/",
               layer = "nga_admbnda_adm2_osgof_20190417") %>%
  st_transform(crs = 26392)
```

After checking both sf dataframes, we notice that NGA provide both LGA and state information. Hence, NGA data.frame will be selected for the subsequent processing.

##### 3.1.2 Importing Aspatial data

As our target is to analysis the water points in Osun State,Nigeria,(the area colored in red) so let's filter the data and selected only the observations in Osun State, Nigeria

![](graph%20used/location%20of%20Osun%20State.jpg){width="380"}

(Fig1: [Location of Osun State](https://en.wikipedia.org/wiki/Osun_State))

```{r}
wp_Osun <- read_csv("data/aspatial/WPdx.csv") %>%
  filter(`#clean_country_name` == "Nigeria") %>%
  filter (`#clean_adm1` == "Osun") 
```

##### 3.1.3 Mappng the geospatial data sets

```{r}
#Let's display the studyarea - Osun on the map:
NGA_Osun <- NGA%>%
  filter(`ADM1_EN` == "Osun")
```

Then, let's ensure that spatial data to be used for analysis has no invalid geometries.

```{r}
length(which(st_is_valid(NGA_Osun) == FALSE))
```

Plot the basemap for osun, Nigeria to check if we obtain the value correctly

```{r}
osungraph = tmap_mode('plot')
tm_shape(NGA_Osun)+tm_polygons()

```

Compared to the map (Fig.1) we know that we have successfully obtained the geospatial information of Osun

##### 

##### 3.1.4 **Converting water point data into sf point features**

In order to convert the point data into sf point feature for further analysis, first we need to convert the wkt field into sfc field by using st_as_sfc() data type.

```{r}
wp_Osun$Geometry = st_as_sfc(wp_Osun$`New Georeferenced Column`)
wp_Osun
```

Then, use st_sf() to convert the tibble data.frame into sf object and also include the referencing system of the data into the sf object. ( Important, don't forget to assign a crs when using st_sf)

```{r}
wp_Osun <- st_sf(wp_Osun, crs=4326)
wp_Osun
```

After assigning a crs to our sf object of wp_Osun, let's transforming it into Nigeria projected coordinate system

```{r}
wp_Osun <- wp_Osun %>%
  st_transform(crs = 26392)
```

Let's if the crs has been assigned properly!

```{r}
st_crs(wp_Osun)
```

#### 3.1.2 **Geospatial Data Cleaning**

##### 3.1.2.2 Checking for duplicate name

It is always important for us to check for duplicate name in the data main data fields. Here are the steps of properly handling the duplication

```{r}
# Get all the duplicated LGA names
duplicated_LGA <- NGA_Osun$ADM2_EN[duplicated(NGA_Osun$ADM2_EN)==TRUE]

# Get all the indices with names that are included in the duplicated LGA names
duplicated_indices <- which(NGA_Osun$ADM2_EN %in% duplicated_LGA)

# For every index in the duplicated_indices, concatenate the two columns with a comma
for (ind in duplicated_indices) {
  NGA_Osun$ADM2_EN[ind] <- paste(NGA_Osun$ADM2_EN[ind], NGA_Osun$ADM1_EN[ind], sep=", ")
}
```

Let's confirm if there is any duplication

```{r}
NGA_Osun$ADM2_EN[duplicated(NGA_Osun$ADM2_EN)==TRUE]
```

Great, let's moving on

**3.1.2.3 Data Wrangling for Water Point Data**

Let's have a quick understanding of our water point data

```{r}
freq(data = wp_Osun,
     input = '#status_clean')
```

We can see that there are **9** classes in the #status_clean field, and there is a class called NA, for easy handling the subsequent steps and make it a more meaningful analysis, we can do following:

-   Recode the NA values into unknown

-   Remove the '\#' sign before the #status_clean field

-   9 classes are a lot, and it is possible to combine them into 3 meaningful classes

```{r}
#recode the NA values into unknown and remove the '#'sign before #status_clean field
wp_Osun <- wp_Osun  %>% 
  rename(status_clean = '#status_clean') %>%
  select(status_clean) %>%
  mutate(status_clean = replace_na(
    status_clean, "unknown"))
```

#### Extracting Water Point Data and combine them into 3 meaningful classes

Now, let's extract the water point data in Osun state according to their status.

To extract functional water point:

```{r}
wp_Osun_functional <- wp_Osun %>%
  filter(status_clean %in%
           c("Functional",
             "Functional but not in use",
             "Functional but needs repair"))
```

To extract non-functional water point:

```{r}
wp_Osun_nonfunctional <- wp_Osun %>%
  filter(status_clean %in%
           c("Abandoned/Decommissioned",
             "Abandoned",
             "Non-Functional due to dry season",
             "Non-Functional",
             "Non functional due to dry season"))
```

To extract water point with unknown status

```{r}
wp_Osun_unknown <- wp_Osun %>%
  filter(status_clean == "unknown")
```

#### 3.1.2Display the kernel density maps on openstreetmap of Osub State, Nigeria.

For displaying the kernel density maps, many geospatial analysis packages required need the input geospatial data to be in sp's Spatial\* classes, so we need to convert simple feature data frame to sp's Spatial\* class.

```{r}
wp_Osun_functional <- as_Spatial(wp_Osun_functional)
wp_Osun_nonfunctional<- as_Spatial(wp_Osun_nonfunctional)
NGA_Osun_sp <- as_Spatial(NGA_Osun)
```

#### **Converting the Spatial\* class into generic sp format**

For further analysis, we need **spatstat** which requires the analytical data in ***ppp*** object form. There is no direct way to convert a Spatial\* classes into ***ppp*** object. We need to convert the ***Spatial*** **classes**\* into ***Spatial*** object first.

Spatial classes-\> Spatial object (Spatial classes usually contains more information than Spatial object, Spatial object only contains the spatial information so it has lesser time to process)

```{r}
wp_Osun_functional_sp <- as(wp_Osun_functional, "SpatialPoints")
wp_Osun_nonfunctional_sp <- as(wp_Osun_nonfunctional, "SpatialPoints")
NGA_Osun_sp<- as(NGA_Osun_sp, "SpatialPolygons")
```

#### Converting the generic sp format into spatstat's ppp format

Now, we will use as.ppp() function of spatstat to convert the spatial data into spatstat's ppp object format, let's do it for both functional and non-function waterpoint data

```{r}
wp_Osun_functional_ppp <- as(wp_Osun_functional, "ppp")
wp_Osun_functional_ppp

```

```{r}
wp_Osun_nonfunctional_ppp <- as(wp_Osun_nonfunctional, "ppp")
wp_Osun_nonfunctional_ppp
```

### Handling duplicated points

It is always important to check if there are duplicated points!

```{r}
any(duplicated(wp_Osun_functional_ppp))
```

```{r}
any(duplicated(wp_Osun_nonfunctional_ppp))
```

There is no duplication point, let's moving on!

### Creating ***owin*** object

When analysing spatial point patterns, it will be good to confine the analysis with a geographical area, in this case, let's confine the analysis within Osun boundary. In spatstat, an object called owin is specially designed to represent this polygonal region.

```{r}
Osun_owin <- as(NGA_Osun_sp, "owin")
```

```{r}
plot(Osun_owin)
```

### Combining point events object and owin object

Now, let's combine both the point and polygon feature in ppp object class

```{r}
wp_Osun_functional_ppp = wp_Osun_functional_ppp[Osun_owin]
wp_Osun_nonfunctional_ppp = wp_Osun_nonfunctional_ppp[Osun_owin]
```

## First-order Spatial Point Patterns Analysis

Let's compute the Kernel Density map for both functional waterpoint and nonfunctional waterpoint in Osun

Let's use bw.diggle() to compute an ideal bandwidth selection method for us and use "gaussian" for our smoothing method

```{r}
kde_Osun_functional_bw<- density(wp_Osun_functional_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian") 
```

```{r}
kde_Osun_nonfunctional_bw<- density(wp_Osun_nonfunctional_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian") 
```

```{r}
plot(kde_Osun_functional_bw)
```

The density values of the output range from 0 to 0.00002 which is way too small to comprehend. This is because the default unit of measurement is in meter. As a result, the density values computed is in "number of points per square meter". so, let's rescale our KDE values

**Rescaling KDE values** Let's convert the unit of measurement from meter to kilometer.

```{r}
wp_Osun_functional_ppp.km <- rescale(wp_Osun_functional_ppp, 1000, "km")
```

```{r}
wp_Osun_nonfunctional_ppp.km <- rescale(wp_Osun_nonfunctional_ppp, 1000, "km")
```

Now, let's plot the map after rescaling

```{r}
kde_Osun_functional.bw <- density(wp_Osun_functional_ppp.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
plot(kde_Osun_functional.bw)
```

```{r}
kde_Osun_nonfunctional.bw <- density(wp_Osun_nonfunctional_ppp.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
plot(kde_Osun_nonfunctional.bw)
```

Fixed bandwidth method is very sensitive to highly skew distribution of spatial point patterns over geographical units for example urban versus rural. One way to overcome this problem is by using adaptive bandwidth instead.

This is the code to compute adaptive bandwidth

```{r}
wp_Osun_functional_adaptive <- adaptive.density(wp_Osun_functional_ppp.km, method="kernel")
plot(wp_Osun_functional_adaptive)
```

```{r}
wp_Osun_nonfunctional_adaptive <- adaptive.density(wp_Osun_nonfunctional_ppp.km, method="kernel")
plot(wp_Osun_nonfunctional_adaptive)
```

We can compare the fixed and adaptive kernel density estimation outputs by using the code chunk below.

Function waterpoint distribution in fixed and adaptive kernel density estimation outputs

```{r}
par(mfrow=c(1,2))
plot(kde_Osun_functional.bw, main = "Fixed bandwidth")
plot(wp_Osun_functional_adaptive, main = "Adaptive bandwidth")
```

Nonfunctional waterpoint distribution in fixed and adaptive kernel density estimation outputs

```{r}
par(mfrow=c(1,2))
plot(kde_Osun_nonfunctional.bw, main = "Fixed bandwidth")
plot(wp_Osun_nonfunctional_adaptive, main = "Adaptive bandwidth")
```

**Converting KDE output into grid object.**
We need to convert the KDE output so that it is suitable for mapping purposes

```{r}
kde_functionalwp_raster <- kde_Osun_functional.bw  %>%
  as.SpatialGridDataFrame.im() %>%
  raster()
kde_functionalwp_raster
```

```{r}
kde_nonfunctionalwp_raster <- kde_Osun_nonfunctional.bw  %>%
  as.SpatialGridDataFrame.im() %>%
  raster()
kde_nonfunctionalwp_raster
```

#### **Assign projection**

```{r}
projection(kde_functionalwp_raster) <- CRS('+init=EPSG:26392')
projection(kde_nonfunctionalwp_raster) <- CRS('+init=EPSG:26392')
kde_functionalwp_raster
kde_nonfunctionalwp_raster
```

### Visualising the output in **tmap**

```{r}
tmap_mode('view')
tm_basemap('OpenStreetMap') +
tm_shape(kde_functionalwp_raster) +
  tm_raster('v') + 
  tm_layout(legend.position = c('right', 'bottom'), 
            frame = FALSE)
```

```{r}
tmap_mode('view')
tm_basemap('OpenStreetMap') +
tm_shape(kde_nonfunctionalwp_raster) +
  tm_raster('v') + 
  tm_layout(legend.position = c('right', 'bottom'), 
            frame = FALSE)
```

#### 3.1.3 Describe the spatial patterns revealed by the kernel density maps. Highlight the advantage of kernel density map over point map.

```{r}
tmap_mode("view")
tm_shape(NGA_Osun) + 
  tm_polygons() +
tm_shape(wp_Osun)+ 
  tm_dots(col = "status_clean",
             size = 0.01,
             border.col = "black",
             border.lwd = 0.5) +
  tm_view(set.zoom.limits = c(8, 16))
```

It looks like the graph has too many colors and it will be better if we group them only in Functional, Nonfunctional, Unknown, so it will be clear to visualize

```{r}
wp_Osun <- wp_Osun %>%
  mutate(status_group = recode(status_clean,
                               "Functional" = "Functional",
                               "Functional but not in use" = "Functional",
                               "Functional but needs repair" = "Functional",
                               "Abandoned/Decommissioned" = "Nonfunctional",
                               "Abandoned" = "Nonfunctional",
                               "Non-Functional due to dry season" = "Nonfunctional",
                               "Non-Functional" = "Nonfunctional",
                               "Non functional due to dry season" = "Nonfunctional",
                               "unknown" = "Unknown"))
```

```{r}
tmap_mode("view")
tm_shape(NGA_Osun) + 
  tm_polygons() +
tm_shape(wp_Osun)+ 
  tm_dots(col = "status_group",
             size = 0.01,
             border.col = "black",
             border.lwd = 0.5) +
  tm_view(set.zoom.limits = c(8, 16))
```

```{r}
plot_functionalwp<- tm_shape(NGA_Osun) + 
  tm_polygons() +
tm_shape(wp_Osun_functional) + 
  tm_dots(size = 0.01)
plot_functionalwp
```

```{r}
plot_nonfunctionalwp<- tm_shape(NGA_Osun) + 
  tm_polygons() +
tm_shape(wp_Osun_nonfunctional) + 
  tm_dots(size = 0.01)
plot_nonfunctionalwp
```

```{r}
par(mfrow=c(1,2))
plot_functionalwp
plot_nonfunctionalwp
```

```{r}
plot(kde_Osun_functional.bw, main = "Functional Waterpoint")
plot(kde_Osun_nonfunctional.bw, main = "Nonfunctional Waterpoint")
```

### 3.2 Second-order Spatial Point Patterns Analysis

#### 3.2.1 Formulate the null hypothesis and alternative hypothesis and select the confidence level.

#### 3.2.2 Perform the test by using appropriate Second order spatial point patterns analysis technique.

#### 3.2.3 With reference to the analysis results, draw statistical conclusions.

```{r}
#to run this code, remove the'#'
#L_ck = Lest(wp_Osun_functional_ppp, correction = "Ripley")
#plot(L_ck, . -r ~ r, 
     #ylab= "L(d)-r", xlab = "d(m)")
```

![](graph%20used/L-function)

```{r}
#L_ck = Lest(wp_Osun_nonfunctional_ppp, correction = "Ripley")
#plot(L_ck, . -r ~ r, 
     #ylab= "L(d)-r", xlab = "d(m)")
```

![](graph%20used/nonfuntonl)

```{r}
#L_ck.csr <- envelope(wp_Osun_functional_ppp, Lest, nsim = 5, rank = 1, glocal=TRUE)
```

```{r}
#plot(L_ck.csr, . - r ~ r, xlab="d", ylab="L(d)-r")
```

![](graph%20used/HYPOFOR%20FUNCTIION%20_GRAPH2)

```{r}
#L_ck.csr <- envelope(wp_Osun_nonfunctional_ppp, Lest, nsim = 5, rank = 1, glocal=TRUE)
```

```{r}
#plot(L_ck.csr, . - r ~ r, xlab="d", ylab="L(d)-r")
```

![](graph%20used/hypo2_nonfunction)

### 3.3 Spatial Correlation Analysis

#### 3.3.1 Formulate the null hypothesis and alternative hypothesis and select the confidence level.

```{r}

```

#### 3.3.2 Perform the test by using appropriate Second order spatial point patterns analysis technique.

#### 3.3.3 With reference to the analysis results, draw statistical conclusions.
